
비트마스크는 각 비트를 활용하여 집합의 상태를 저장하고 조작하는 방법입니다. 각 비트는 0 또는 1의 값을 가지며, 특정 원소가 집합에 포함되었는지 아닌지를 나타낼 수 있습니다. 문제에서 1부터 20까지의 숫자를 다루기 때문에, 20개의 비트를 사용하는 비트마스크를 통해 각 숫자를 집합에 포함할지 여부를 표현할 수 있습니다.

### 비트마스크 연산 원리

1. **add x: S에 x를 추가한다.**
   - `S |= (1 << (x - 1))`
     - `(1 << (x - 1))`은 x번째 비트를 1로 설정하고 나머지 비트를 0으로 만듭니다. 예를 들어, x=3이면 `1 << 2`는 4(이진수 000100)가 됩니다.
     - `S |=`는 S와 위의 결과를 비트 OR 연산합니다. OR 연산을 통해 x번째 비트를 1로 설정하고 나머지 비트는 그대로 유지됩니다.

2. **remove x: S에서 x를 제거한다.**
   - `S &= ~(1 << (x - 1))`
     - `(1 << (x - 1))`은 위와 동일하게 x번째 비트를 1로 설정합니다.
     - `~`는 비트를 반전시켜 x번째 비트를 0으로 만들고 나머지는 1로 만듭니다.
     - `S &=`는 S와 위의 결과를 비트 AND 연산합니다. AND 연산을 통해 x번째 비트를 0으로 설정하고 나머지 비트는 그대로 유지됩니다.

3. **check x: S에 x가 있으면 1을, 없으면 0을 출력한다.**
   - `(S & (1 << (x - 1))) != 0`
     - `(1 << (x - 1))`은 위와 동일하게 x번째 비트를 1로 설정합니다.
     - `S &`는 S와 위의 결과를 비트 AND 연산합니다. x번째 비트가 1이면 결과는 0이 아니고, 0이면 결과는 0이 됩니다.
     - 따라서 결과가 0이 아니면 x가 집합에 포함되어 있는 것이고, 0이면 포함되지 않은 것입니다.

4. **toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다.**
   - `S ^= (1 << (x - 1))`
     - `(1 << (x - 1))`은 위와 동일하게 x번째 비트를 1로 설정합니다.
     - `S ^`는 S와 위의 결과를 비트 XOR 연산합니다. XOR 연산은 두 비트가 다를 때 1을 반환합니다. 따라서 x번째 비트가 1이면 0으로, 0이면 1로 반전됩니다.

5. **all: S를 {1, 2, ..., 20}으로 바꾼다.**
   - `S = (1 << 20) - 1`
     - `(1 << 20)`은 21번째 비트만 1이고 나머지는 0인 값입니다. 이 값은 2^20입니다.
     - `- 1`을 하면 하위 20개의 비트가 모두 1이 됩니다. 즉, 이 값은 20개의 비트가 모두 1인 값을 나타내며, 이는 {1, 2, ..., 20}이 모두 포함된 상태를 의미합니다.

6. **empty: S를 공집합으로 바꾼다.**
   - `S = 0`
     - 모든 비트를 0으로 설정하여 집합을 공집합으로 만듭니다.

이와 같이 비트 연산을 사용하면 각 연산이 매우 효율적으로 수행될 수 있습니다. 각 연산은 O(1) 시간 복잡도를 가지며, 이는 매우 빠릅니다.
